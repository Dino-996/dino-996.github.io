<p>layout: layouts/post.njk
title: Processi
description: Vengono esaminati i meccanismi di gestione della memoria, illustrando la differenza tra l'allocazione dinamica nello heap e l'utilizzo temporaneo dello stack per le chiamate di funzione. Process Control Block (PCB), una struttura dati fondamentale che memorizza lo stato, i registri e le informazioni di scheduling necessarie alla CPU.
tags:</p>
<ul>
<li>posts</li>
<li>sistemi operativi
date: 2020-02-10
excerpt: In questo articolo approfondiamo l'architettura dei processi all'interno dei sistemi operativi, distinguendo tra il concetto di programma statico e quello di entità attiva in esecuzione.
permalink: &quot;/blog//&quot;
image: \assets\img\png\strutture-dei-sistemi-operativi.png
imageAlt: &quot;Immagine generata con AI&quot;</li>
</ul>
<hr>
<h1></h1>
<h2>Introduzione</h2>
<h1>Processi</h1>
<h2>Che cos'è un processo?</h2>
<p>Un <strong>processo</strong> è definito come un <strong>programma in esecuzione</strong>: un’entità attiva dotata di un contatore di programma e di un insieme di risorse associate. Si distingue dal programma, che è invece un’entità passiva, ad esempio un file memorizzato su disco.</p>
<p>In <strong>memoria</strong>, un processo è suddiviso in sezioni specifiche:</p>
<ul>
<li><strong>Testo (Text Segment)</strong>: contiene il codice eseguibile.</li>
<li><strong>Dati (Data Segment)</strong>: contiene le variabili globali e statiche.</li>
<li><strong>Heap</strong>: area di memoria allocata dinamicamente durante l’esecuzione.</li>
<li><strong>Stack</strong>: memoria temporanea utilizzata per le chiamate di funzione e le variabili locali.</li>
</ul>
<p>Nei sistemi moderni il concetto si estende ai <strong>thread</strong>, che consentono a un singolo processo di avere più percorsi di esecuzione concorrenti, facilitando il parallelismo nei sistemi multicore.</p>
<h2>Il core e il multicore</h2>
<p>Un <strong>core</strong> è un’unità di calcolo fisica indipendente all’interno della CPU.</p>
<p>Una CPU contiene tipicamente:</p>
<ul>
<li><strong>Registri</strong></li>
<li><strong>ALU (Arithmetic Logic Unit)</strong></li>
<li><strong>Logica di controllo</strong></li>
<li>Capacità di eseguire un <strong>flusso di istruzioni indipendente</strong></li>
</ul>
<p>Fino ai primi anni 2000, le CPU disponevano generalmente di un solo core. Ciò significava che poteva essere eseguita una sola istruzione alla volta per ciascun ciclo di clock.</p>
<p>Il sistema operativo utilizzava il <strong>time slicing</strong>, una tecnica che assegna a ciascun processo un intervallo di tempo limitato di utilizzo della CPU (time slice). Ad esempio:</p>
<ul>
<li>Processo A per 5 ms</li>
<li>Processo B per 5 ms</li>
<li>Processo C per 5 ms</li>
<li>Ritorno al processo A</li>
</ul>
<p>Il cambio tra processi (context switch) avviene così rapidamente da risultare impercettibile all’utente. Tuttavia, il core esegue comunque una sola istruzione per volta: il parallelismo è simulato.</p>
<p>In un sistema <strong>multicore</strong>, invece, esistono più core fisici. Di conseguenza:</p>
<ul>
<li>Il core 1 può eseguire il thread A</li>
<li>Il core 2 può eseguire il thread B</li>
<li>Il core 3 può eseguire il thread C</li>
</ul>
<p>Tutto nello stesso istante fisico. In questo caso il <strong>parallelismo è reale</strong>, non simulato.</p>
<p>Un processo può avere più thread. Ogni thread:</p>
<ul>
<li>È un percorso di esecuzione indipendente</li>
<li>Possiede un proprio program counter</li>
<li>Ha un proprio stack</li>
<li>Condivide l’heap e le risorse del processo con gli altri thread</li>
</ul>
<p>Ad esempio, con un processo composto da 4 thread e una CPU a 4 core, il sistema operativo può assegnare un thread a ciascun core, eseguendo il programma in parallelo su più unità fisiche.</p>
<h2>Stato e controllo del processo</h2>
<p>Ogni processo attraversa diversi stati durante il suo ciclo di vita: <strong>nuovo</strong>, <strong>pronto</strong>, <strong>esecuzione</strong>, <strong>attesa</strong> e <strong>terminato</strong>.</p>
<p>Il sistema operativo rappresenta ogni processo tramite un <strong>PCB (Process Control Block)</strong>, che memorizza informazioni cruciali quali:</p>
<ul>
<li>Stato corrente</li>
<li>PID (Process Identifier)</li>
<li>Contatore di programma</li>
<li>Registri della CPU</li>
<li>Informazioni di memoria</li>
</ul>
<h2>Il ciclo di vita di un processo</h2>
<p>Un processo può trovarsi nei seguenti stati:</p>
<ul>
<li><strong>Nuovo (New)</strong>: è stato creato ma non è ancora pronto per l’esecuzione.</li>
<li><strong>Pronto (Ready)</strong>: è in memoria e attende l’assegnazione della CPU.</li>
<li><strong>Esecuzione (Running)</strong>: sta utilizzando la CPU.</li>
<li><strong>Attesa (Waiting/Blocked)</strong>: è in attesa di un evento esterno, tipicamente un’operazione di I/O.</li>
<li><strong>Terminato (Terminated)</strong>: ha completato la propria esecuzione.</li>
</ul>
<p>Questi stati determinano in quale struttura dati del kernel il processo viene inserito e quali operazioni possono essere effettuate su di esso.</p>
<h2>Code di scheduling</h2>
<p>Il sistema operativo mantiene diverse code:</p>
<ul>
<li><strong>Ready Queue</strong>: contiene i processi pronti all’esecuzione.</li>
<li><strong>Waiting Queue</strong>: contiene i processi in attesa di eventi.</li>
<li><strong>Device Queue</strong>: una coda per ciascun dispositivo di I/O.</li>
</ul>
<p>Quando un processo richiede un’operazione di I/O:</p>
<ol>
<li>Viene spostato nella coda del dispositivo.</li>
<li>Il kernel assegna la CPU a un altro processo pronto.</li>
<li>Al termine dell’I/O (tramite interrupt), il processo torna nella ready queue.</li>
</ol>
<h2>Il Process Control Block (PCB)</h2>
<p>Il <strong>PCB</strong> è la struttura dati con cui il kernel rappresenta un processo.</p>
<p>Contiene:</p>
<ul>
<li>Stato del processo</li>
<li>PID</li>
<li>Program counter</li>
<li>Registri della CPU</li>
<li>Informazioni di scheduling (priorità, puntatori alle code)</li>
<li>Informazioni di memoria (tabelle delle pagine, limiti)</li>
<li>File aperti e risorse allocate</li>
<li>Informazioni di accounting (tempo di CPU utilizzato)</li>
</ul>
<p>Il PCB risiede nello spazio kernel ed è accessibile esclusivamente al sistema operativo.</p>
<h2>Context switch</h2>
<p>Il <strong>context switch</strong> è il meccanismo con cui il sistema operativo interrompe un processo e ne attiva un altro.</p>
<p>Le operazioni principali sono:</p>
<ol>
<li>Salvare registri e program counter nel PCB del processo corrente.</li>
<li>Selezionare un processo dalla ready queue.</li>
<li>Ripristinare lo stato del nuovo processo dal suo PCB.</li>
</ol>
<p>Il context switch rappresenta un overhead inevitabile del multitasking.</p>
<h2>Scheduling e politiche decisionali</h2>
<p>La scelta del processo successivo dipende dall’algoritmo di scheduling:</p>
<ul>
<li><strong>FCFS (First Come, First Served)</strong></li>
<li><strong>SJF (Shortest Job First)</strong></li>
<li><strong>Round Robin</strong></li>
<li><strong>Priority Scheduling</strong></li>
</ul>
<p>Ogni algoritmo ottimizza metriche diverse:</p>
<ul>
<li>Tempo medio di attesa</li>
<li>Tempo di risposta</li>
<li>Throughput</li>
<li>Equità</li>
</ul>
<p>Non esiste una soluzione universalmente ottimale: la scelta dipende dal contesto applicativo.</p>
<h2>Stati estesi</h2>
<p>Nei sistemi operativi moderni esistono stati aggiuntivi.</p>
<h3>Suspended</h3>
<p>Indica che il processo è temporaneamente escluso dalla competizione per la CPU.</p>
<p>Può accadere per:</p>
<ul>
<li>Swapping su disco</li>
<li>Sospensione amministrativa</li>
<li>Politiche di gestione delle risorse</li>
</ul>
<p>Differenza fondamentale:</p>
<ul>
<li><strong>Waiting</strong>: attesa di un evento.</li>
<li><strong>Suspended</strong>: esclusione per decisione del sistema o gestione della memoria.</li>
</ul>
<h3>Zombie</h3>
<p>Un processo <strong>zombie</strong> ha terminato l’esecuzione ma il suo PCB non è ancora stato rimosso.</p>
<p>Il processo:</p>
<ol>
<li>Rilascia le risorse.</li>
<li>Conserva nel PCB il codice di uscita.</li>
<li>Attende che il padre invochi <code>wait()</code>.</li>
</ol>
<p>Non consuma CPU, ma occupa una voce nella tabella dei processi.</p>
<h3>Orphan</h3>
<p>Un processo <strong>orfano</strong> è un processo il cui padre termina prima di lui.</p>
<p>Nei sistemi Unix-like viene adottato dal processo <code>init</code> (PID 1) o da un suo equivalente, che si occuperà di raccoglierne lo stato finale.</p>
<h2>Coordinamento nei sistemi multicore</h2>
<p>Nei sistemi multicore:</p>
<ul>
<li>Più CPU eseguono in parallelo.</li>
<li>Le strutture dati del kernel sono condivise.</li>
<li>Le decisioni di scheduling possono avvenire simultaneamente.</li>
</ul>
<h3>Strutture condivise</h3>
<ul>
<li>Ready queue</li>
<li>Tabelle dei processi (PCB)</li>
<li>Tabelle delle pagine</li>
</ul>
<p>Accessi concorrenti possono causare condizioni di race.</p>
<h3>Meccanismi di sincronizzazione</h3>
<p>Il kernel utilizza:</p>
<ul>
<li>Spinlock</li>
<li>Mutex</li>
<li>Sezioni critiche</li>
<li>Disabilitazione temporanea degli interrupt</li>
</ul>
<p>per garantire coerenza.</p>
<h3>Affinità della CPU</h3>
<p>La <strong>CPU affinity</strong> consente di associare preferenzialmente un processo a un core specifico per:</p>
<ul>
<li>Migliorare la località della cache</li>
<li>Ridurre il costo di migrazione tra core</li>
</ul>
<p>La migrazione tra core comporta invalidazioni di cache e costi aggiuntivi.</p>
<h2>Comunicazione tra processi (IPC)</h2>
<p>I processi cooperanti utilizzano meccanismi di <strong>IPC (InterProcess Communication)</strong>.</p>
<p>Due modelli principali:</p>
<ul>
<li><strong>Memoria condivisa</strong>: comunicazione tramite una regione di memoria comune; è veloce ma richiede sincronizzazione.</li>
<li><strong>Scambio di messaggi</strong>: basato su primitive <code>send()</code> e <code>receive()</code>, può essere sincrono (bloccante) o asincrono (non bloccante).</li>
</ul>
<h2>Esempi di sistemi IPC e comunicazione client-server</h2>
<ul>
<li><strong>Pipe</strong>: canali di comunicazione, tipicamente tra processi correlati.</li>
<li><strong>Socket</strong>: identificati da indirizzo IP e porta; fondamentali per la comunicazione in rete (TCP e UDP).</li>
<li><strong>RPC (Remote Procedure Call)</strong>: permettono di invocare procedure remote come se fossero locali.</li>
<li><strong>Sistemi specifici</strong>: Mach utilizza porte e messaggi; Windows impiega le <strong>ALPC (Advanced Local Procedure Call)</strong> per la comunicazione locale.</li>
</ul>
